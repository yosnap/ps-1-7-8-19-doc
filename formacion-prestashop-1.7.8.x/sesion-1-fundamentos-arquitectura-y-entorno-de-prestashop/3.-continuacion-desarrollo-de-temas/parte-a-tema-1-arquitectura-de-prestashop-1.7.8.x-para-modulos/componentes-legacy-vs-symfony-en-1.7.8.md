# Componentes Legacy vs Symfony en 1.7.8

* **Conceptos Clave:**
  * **Legacy:** C√≥digo m√°s antiguo, a menudo usando patrones como ObjectModels est√°ticos, acceso global al `Context`, y plantillas Smarty. Muchas partes del BO y FO a√∫n dependen de esto.
  * **Symfony:** Implementaci√≥n progresiva del framework Symfony para modernizar PrestaShop. Esto incluye el uso de Controladores Symfony, Servicios, Inyecci√≥n de Dependencias, Doctrine (parcialmente) y plantillas Twig para nuevas secciones del BO (como la p√°gina de Producto, M√≥dulos) y partes del FO (como el checkout).
  * La carpeta `/src/PrestaShopBundle` contiene gran parte del c√≥digo Symfony del Core. Los `Adapter` en `/src/Adapter` sirven de puente entre el mundo legacy y el nuevo.
* **Actividad en Clase / Ejemplo Pr√°ctico:**
  * **Navegaci√≥n Guiada por el Back Office:** Abriremos la p√°gina de gesti√≥n de "Productos" (basada en Symfony) y la compararemos con la p√°gina de "Clientes" (m√°s legacy). Discutiremos las diferencias en estructura de URL, apariencia y comportamiento.
  * Observaremos brevemente el c√≥digo fuente de un controlador legacy y uno Symfony del Core para ver las diferencias estructurales.

<figure><img src="../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

#### Tabla Comparativa: P√°ginas Legacy vs. P√°ginas Symfony

| Caracter√≠stica      | P√°ginas "Legacy" (ej. Clientes)                 | P√°ginas "Symfony" (ej. Productos)                     |
| ------------------- | ----------------------------------------------- | ----------------------------------------------------- |
| Framework           | Framework propio y "casero" de PrestaShop.      | Symfony (Full-Stack).                                 |
| Routing             | Basado en el par√°metro controller.              | Sistema de Rutas de Symfony (@Route o YAML).          |
| Controlador Base    | Hereda de AdminController.                      | Hereda de FrameworkBundleAdminController.             |
| Gesti√≥n Petici√≥n    | M√©todos monol√≠ticos (initContent, postProcess). | Acciones espec√≠ficas (listAction, editAction).        |
| Motor de Plantillas | Smarty (archivos .tpl).                         | Twig (archivos .html.twig).                           |
| Formularios         | HelperForm (r√≠gido y limitado).                 | Componente Symfony Forms (flexible y potente).        |
| Acceso a Datos      | Clases ObjectModel, DbQuery, HelperList.        | Doctrine ORM (Repositorios, Entidades).               |
| Dependencias        | Acceso global con $this->context.               | Inyecci√≥n de Dependencias en el constructor.          |
| Experiencia Usuario | Recargas de p√°gina completas. M√°s lento.        | Reactivo (AJAX, a veces Vue.js). M√°s r√°pido y fluido. |
| Mantenibilidad      | C√≥digo m√°s acoplado y dif√≠cil de testear.       | C√≥digo desacoplado, m√°s f√°cil de mantener y testear.  |

## PrestaShop: Legacy vs Moderno - Comparaci√≥n Pr√°ctica

### üèõÔ∏è C√ìDIGO LEGACY (Forma antigua)

#### Estructura de archivos legacy

```
prestashop/
‚îú‚îÄ‚îÄ classes/
‚îÇ   ‚îú‚îÄ‚îÄ Product.php           ‚Üê Clase sin namespace
‚îÇ   ‚îú‚îÄ‚îÄ Cart.php              ‚Üê Clase sin namespace  
‚îÇ   ‚îú‚îÄ‚îÄ Customer.php          ‚Üê Clase sin namespace
‚îÇ   ‚îî‚îÄ‚îÄ Order.php             ‚Üê Clase sin namespace
‚îî‚îÄ‚îÄ modules/
    ‚îî‚îÄ‚îÄ mi_modulo_viejo/
        ‚îú‚îÄ‚îÄ mi_modulo_viejo.php
        ‚îî‚îÄ‚îÄ classes/
            ‚îî‚îÄ‚îÄ MiClaseVieja.php  ‚Üê Sin namespace
```

#### Ejemplo de clase legacy

```php
<?php
// Archivo: classes/Product.php
// ‚ö†Ô∏è SIN NAMESPACE

class Product extends ObjectModel
{
    public $id;
    public $name;
    public $price;
    
    public function __construct($id = null)
    {
        parent::__construct($id);
    }
    
    public function save()
    {
        // L√≥gica para guardar
        return parent::save();
    }
}
```

#### C√≥mo se usa el c√≥digo legacy

```php
<?php
// En cualquier parte de PrestaShop legacy

// 1. Instanciaci√≥n directa (autoloader de PrestaShop)
$product = new Product(123);
$cart = new Cart(456);
$customer = new Customer(789);

// 2. Acceso a propiedades y m√©todos
$product->name = 'Mi producto';
$product->price = 29.99;
$product->save();

// 3. Sin imports necesarios
$order = new Order();
$order->id_customer = $customer->id;

// 4. Funciona por el autoloader legacy de PrestaShop
echo "Producto: " . $product->name;
```

***

### üöÄ C√ìDIGO MODERNO (Con namespaces)

#### Estructura de archivos moderna

```
mi_modulo/
‚îú‚îÄ‚îÄ composer.json             ‚Üê Configuraci√≥n de autoloading
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ Controller/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProductController.php
‚îÇ   ‚îú‚îÄ‚îÄ Service/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductService.php
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PriceCalculator.php
‚îÇ   ‚îú‚îÄ‚îÄ Entity/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CustomProduct.php
‚îÇ   ‚îî‚îÄ‚îÄ Repository/
‚îÇ       ‚îî‚îÄ‚îÄ ProductRepository.php
‚îú‚îÄ‚îÄ mi_modulo.php
‚îî‚îÄ‚îÄ vendor/
    ‚îî‚îÄ‚îÄ autoload.php          ‚Üê Generado por Composer
```

#### Configuraci√≥n composer.json

```json
{
  "name": "mi-empresa/mi-modulo",
  "autoload": {
    "psr-4": {
      "MiEmpresa\\MiModulo\\": "src/"
    }
  },
  "require": {
    "php": ">=7.4"
  }
}
```

#### Ejemplo de clase moderna

```php
<?php
// Archivo: src/Service/ProductService.php

namespace MiEmpresa\MiModulo\Service;

use MiEmpresa\MiModulo\Entity\CustomProduct;
use MiEmpresa\MiModulo\Repository\ProductRepository;
use PrestaShop\PrestaShop\Adapter\Entity\Product; // Clase legacy

class ProductService
{
    private $repository;
    
    public function __construct(ProductRepository $repository)
    {
        $this->repository = $repository;
    }
    
    public function createCustomProduct(string $name, float $price): CustomProduct
    {
        $customProduct = new CustomProduct();
        $customProduct->setName($name);
        $customProduct->setPrice($price);
        
        return $this->repository->save($customProduct);
    }
    
    public function convertLegacyProduct(int $productId): CustomProduct
    {
        // Usando clase legacy dentro de c√≥digo moderno
        $legacyProduct = new Product($productId);
        
        $customProduct = new CustomProduct();
        $customProduct->setName($legacyProduct->name);
        $customProduct->setPrice($legacyProduct->price);
        
        return $customProduct;
    }
}
```

#### C√≥mo se usa el c√≥digo moderno

```php
<?php
// Archivo: mi_modulo.php

// 1. OBLIGATORIO: Incluir autoloader de Composer
require_once __DIR__ . '/vendor/autoload.php';

// 2. Imports expl√≠citos (obligatorios)
use MiEmpresa\MiModulo\Service\ProductService;
use MiEmpresa\MiModulo\Service\PriceCalculator;
use MiEmpresa\MiModulo\Repository\ProductRepository;
use MiEmpresa\MiModulo\Entity\CustomProduct;

class MiModulo extends Module
{
    public function install()
    {
        // 3. Instanciaci√≥n con namespaces
        $repository = new ProductRepository();
        $service = new ProductService($repository);
        $calculator = new PriceCalculator();
        
        // 4. Uso de m√©todos
        $product = $service->createCustomProduct('Producto Premium', 99.99);
        $finalPrice = $calculator->calculateWithTax($product->getPrice());
        
        return parent::install();
    }
    
    public function mixingLegacyAndModern()
    {
        // MEZCLANDO: Legacy + Moderno
        
        // Clase legacy (sin namespace)
        $legacyProduct = new Product(123);
        
        // Clases modernas (con namespace)
        $repository = new ProductRepository();
        $service = new ProductService($repository);
        
        // Convertir legacy a moderno
        $modernProduct = $service->convertLegacyProduct($legacyProduct->id);
        
        return $modernProduct;
    }
}
```

***

### üìä COMPARACI√ìN LADO A LADO

| Aspecto          | Legacy                      | Moderno                         |
| ---------------- | --------------------------- | ------------------------------- |
| **Namespaces**   | ‚ùå No usa                    | ‚úÖ Usa PSR-4                     |
| **Autoloader**   | PrestaShop propio           | Composer + PSR-4                |
| **Imports**      | No necesarios               | `use` obligatorio               |
| **Estructura**   | `classes/NombreClase.php`   | `src/Categoria/NombreClase.php` |
| **Conflictos**   | Posibles (nombres globales) | Imposibles (namespaces)         |
| **Organizaci√≥n** | Carpeta plana               | Estructura jer√°rquica           |
| **Est√°ndares**   | PrestaShop espec√≠fico       | PSR-4 universal                 |
| **IDE Support**  | Limitado                    | Excelente                       |

***

### üîÑ EVOLUCI√ìN EN LA PR√ÅCTICA

#### Antes (Legacy)

```php
// Todo en el espacio global
$product = new Product();
$cart = new Cart();
$helper = new Helper(); // ¬øCu√°l Helper? ¬°Conflicto!
```

#### Ahora (Moderno)

```php
use MiModulo\Service\ProductService;
use MiModulo\Helper\PriceHelper;
use OtroModulo\Helper\DateHelper;

$productService = new ProductService();
$priceHelper = new PriceHelper();     // Sin conflictos
$dateHelper = new DateHelper();       // Sin conflictos
```

***

### üéØ VENTAJAS DEL C√ìDIGO MODERNO

#### 1. **Organizaci√≥n Clara**

```php
// Es obvio qu√© hace cada clase por su namespace
MiModulo\Controller\AdminProductController  ‚Üí Controlador admin
MiModulo\Service\EmailService              ‚Üí Servicio de email  
MiModulo\Repository\ProductRepository      ‚Üí Repositorio de productos
```

#### 2. **Sin Conflictos**

```php
// Puedes tener m√∫ltiples clases "Product" sin problemas
use MiModulo\Entity\Product as CustomProduct;
use PrestaShop\PrestaShop\Adapter\Entity\Product as LegacyProduct;
use OtroModulo\Model\Product as ExternalProduct;

$custom = new CustomProduct();
$legacy = new LegacyProduct();
$external = new ExternalProduct();
```

#### 3. **Mejor IDE Support**

```php
use MiModulo\Service\ProductService;

$service = new ProductService();
$service->  // ‚Üê El IDE te sugiere todos los m√©todos disponibles
```

***

### üö® ERRORES COMUNES EN LA TRANSICI√ìN

#### ‚ùå Olvidar el autoloader

```php
// Error: No incluir el autoloader
use MiModulo\Service\ProductService;
$service = new ProductService(); // ¬°Fatal Error!
```

#### ‚úÖ Correcto

```php
require_once __DIR__ . '/vendor/autoload.php';
use MiModulo\Service\ProductService;
$service = new ProductService(); // ‚úÖ Funciona
```

#### ‚ùå Mezclar estilos incorrectamente

```php
// Error: Intentar usar namespace en clase legacy
use Product; // ¬°Product no tiene namespace!
```

#### ‚úÖ Correcto

```php
// Las clases legacy se usan directamente
$legacyProduct = new Product();

// Las modernas con namespace
use MiModulo\Entity\CustomProduct;
$modernProduct = new CustomProduct();
```

***

### üéì CONCLUSI√ìN

La evoluci√≥n de **legacy** ‚Üí **moderno** representa:

* **Mejor organizaci√≥n** del c√≥digo
* **Eliminaci√≥n de conflictos** de nombres
* **Compatibilidad** con est√°ndares universales
* **Mejor experiencia** de desarrollo
* **C√≥digo m√°s mantenible** y escalable

**PrestaShop 1.7+** permite usar **ambos estilos**, facilitando la migraci√≥n gradual.
